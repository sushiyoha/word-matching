import React, { useState, useEffect, useCallback } from 'react';
import { Link } from 'react-router-dom';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { Separator } from '@/components/ui/separator';
import { 
  Play, 
  RotateCcw, 
  Trophy, 
  Clock, 
  Target, 
  RefreshCw,
  Plus,
  Minus,
  Settings2,
  ArrowLeft,
  Crown,
  Medal
} from 'lucide-react';
import { toast } from 'sonner';
import { wordLibraryApi, wordPairApi, gameRecordApi } from '@/db/api';
import type { WordLibrary, WordPair, GameCard, GameState } from '@/types';
import GameBoard from '@/components/game/GameBoard';
import Leaderboard from '@/components/game/Leaderboard';

const WordMatchGame: React.FC = () => {
  const [libraries, setLibraries] = useState<WordLibrary[]>([]);
  const [selectedLibrary, setSelectedLibrary] = useState<WordLibrary | null>(null);
  const [wordPairs, setWordPairs] = useState<WordPair[]>([]);
  const [currentWords, setCurrentWords] = useState<WordPair[]>([]);
  const [wordCount, setWordCount] = useState(10);
  const [playerName, setPlayerName] = useState('');
  const [showLeaderboard, setShowLeaderboard] = useState(false);
  const [showAddWords, setShowAddWords] = useState(false);
  const [leaderboardRefreshKey, setLeaderboardRefreshKey] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  const [userRank, setUserRank] = useState<number | null>(null);
  const [firstPlaceRecord, setFirstPlaceRecord] = useState<{ playerName: string; time: number; steps: number } | null>(null);
  const [gameCount, setGameCount] = useState(0);
  
  const [gameState, setGameState] = useState<GameState>({
    cards: [],
    selectedCards: [],
    matchedPairs: 0,
    steps: 0,
    startTime: null,
    endTime: null,
    isGameStarted: false,
    isGameCompleted: false
  });

  // åŠ è½½è¯åº“
  useEffect(() => {
    const loadLibraries = async () => {
      const libs = await wordLibraryApi.getAll();
      setLibraries(libs);
      
      // é»˜è®¤é€‰æ‹©ç¬¬ä¸€ä¸ªè¯åº“
      if (libs.length > 0) {
        const defaultLib = libs.find(lib => lib.is_default) || libs[0];
        setSelectedLibrary(defaultLib);
      }
    };
    
    loadLibraries();
  }, []);

  // æ¸¸æˆè®¡æ—¶å™¨
  useEffect(() => {
    let interval: NodeJS.Timeout;
    
    if (gameState.isGameStarted && !gameState.isGameCompleted && gameState.startTime) {
      interval = setInterval(() => {
        setCurrentTime(Math.floor((Date.now() - gameState.startTime!) / 1000));
      }, 1000);
    } else {
      setCurrentTime(0);
    }

    return () => {
      if (interval) {
        clearInterval(interval);
      }
    };
  }, [gameState.isGameStarted, gameState.isGameCompleted, gameState.startTime]);

  // åŠ è½½é€‰ä¸­è¯åº“çš„å•è¯å¯¹
  useEffect(() => {
    if (selectedLibrary) {
      const loadWordPairs = async () => {
        const pairs = await wordPairApi.getByLibraryId(selectedLibrary.id);
        setWordPairs(pairs);
        // é»˜è®¤æ˜¾ç¤ºå‰10ä¸ªå•è¯
        refreshWords(pairs, wordCount);
      };
      
      loadWordPairs();
    }
  }, [selectedLibrary, wordCount]);

  // ä»localStorageè·å–ç©å®¶åç§°
  useEffect(() => {
    const savedPlayerName = localStorage.getItem('wordMatchGame_playerName');
    if (savedPlayerName) {
      setPlayerName(savedPlayerName);
    }
  }, []);

  // ä¿å­˜ç©å®¶åç§°åˆ°localStorage
  const savePlayerName = useCallback((name: string) => {
    setPlayerName(name);
    localStorage.setItem('wordMatchGame_playerName', name);
  }, []);

  // åˆ·æ–°å•è¯
  const refreshWords = useCallback((pairs: WordPair[] = wordPairs, count: number = wordCount) => {
    if (pairs.length === 0) return;
    
    // éšæœºé€‰æ‹©æŒ‡å®šæ•°é‡çš„å•è¯å¯¹
    const shuffled = [...pairs].sort(() => Math.random() - 0.5);
    const selected = shuffled.slice(0, Math.min(count, pairs.length));
    setCurrentWords(selected);
  }, [wordPairs, wordCount]);

  // åˆ›å»ºæ¸¸æˆå¡ç‰‡
  const createGameCards = useCallback((pairs: WordPair[], showContent: boolean = false): GameCard[] => {
    // åˆ›å»ºå¡ç‰‡æ•°ç»„
    const cards: GameCard[] = [];
    
    pairs.forEach((pair, index) => {
      const pairId = `pair-${index}`;
      
      // è‹±æ–‡å¡ç‰‡
      cards.push({
        id: `${pairId}-en`,
        content: pair.english_word,
        type: 'english',
        pairId,
        isFlipped: showContent,
        isMatched: false
      });
      
      // ä¸­æ–‡å¡ç‰‡
      cards.push({
        id: `${pairId}-zh`,
        content: pair.chinese_translation,
        type: 'chinese',
        pairId,
        isFlipped: showContent,
        isMatched: false
      });
    });

    // æ‰“ä¹±å¡ç‰‡é¡ºåº
    return cards.sort(() => Math.random() - 0.5);
  }, []);

  // å¼€å§‹æ¸¸æˆ
  const startGame = useCallback(() => {
    if (!selectedLibrary || currentWords.length === 0) {
      toast.error('è¯·å…ˆåˆ·æ–°å•è¯');
      return;
    }

    // å…ˆåˆ›å»ºæ˜¾ç¤ºæ­£é¢å†…å®¹çš„å¡ç‰‡
    const cardsWithContent = createGameCards(currentWords, true);
    
    setGameState({
      cards: cardsWithContent,
      selectedCards: [],
      matchedPairs: 0,
      steps: 0,
      startTime: Date.now(),
      endTime: null,
      isGameStarted: true,
      isGameCompleted: false
    });

    // 0.5ç§’åå°†æ‰€æœ‰å¡ç‰‡ç¿»è½¬åˆ°èƒŒé¢
    setTimeout(() => {
      setGameState(prevState => ({
        ...prevState,
        cards: prevState.cards.map(card => ({
          ...card,
          isFlipped: false
        }))
      }));
    }, 500);
  }, [selectedLibrary, currentWords, createGameCards]);

  // é‡ç½®æ¸¸æˆ
  const resetGame = useCallback(() => {
    setGameState({
      cards: [],
      selectedCards: [],
      matchedPairs: 0,
      steps: 0,
      startTime: null,
      endTime: null,
      isGameStarted: false,
      isGameCompleted: false
    });
    // æ¸…é™¤æ’åä¿¡æ¯
    setUserRank(null);
    setFirstPlaceRecord(null);
  }, []);

  // é‡æ–°å¼€å§‹æ¸¸æˆï¼ˆä¿æŒå½“å‰è®¾ç½®ï¼‰
  const restartGame = useCallback(() => {
    if (!selectedLibrary || currentWords.length === 0) {
      toast.error('è¯·å…ˆé€‰æ‹©è¯åº“å¹¶ç¡®ä¿æœ‰å•è¯');
      return;
    }

    // é‡æ–°åˆ›å»ºæ¸¸æˆå¡ç‰‡å¹¶å¼€å§‹æ¸¸æˆ
    const cardsWithContent = createGameCards(currentWords, true);
    
    setGameState({
      cards: cardsWithContent,
      selectedCards: [],
      matchedPairs: 0,
      steps: 0,
      startTime: Date.now(),
      endTime: null,
      isGameStarted: true,
      isGameCompleted: false
    });
    
    // æ¸…é™¤æ’åä¿¡æ¯
    setUserRank(null);
    setFirstPlaceRecord(null);

    toast.success('æ¸¸æˆé‡æ–°å¼€å§‹ï¼');

    // 0.5ç§’åå°†æ‰€æœ‰å¡ç‰‡ç¿»è½¬åˆ°èƒŒé¢
    setTimeout(() => {
      setGameState(prevState => ({
        ...prevState,
        cards: prevState.cards.map(card => ({
          ...card,
          isFlipped: false
        }))
      }));
    }, 500);
  }, [selectedLibrary, currentWords, createGameCards]);

  // å¤„ç†å¡ç‰‡ç‚¹å‡»
  const handleCardClick = useCallback((cardId: string) => {
    setGameState(prevState => {
      const { cards, selectedCards, steps, matchedPairs } = prevState;
      
      // å¦‚æœå·²ç»é€‰æ‹©äº†ä¸¤å¼ å¡ç‰‡ï¼Œæˆ–è€…å¡ç‰‡å·²ç»è¢«åŒ¹é…ï¼Œåˆ™å¿½ç•¥ç‚¹å‡»
      if (selectedCards.length >= 2) return prevState;
      
      const clickedCard = cards.find(card => card.id === cardId);
      if (!clickedCard || clickedCard.isMatched || clickedCard.isFlipped) {
        return prevState;
      }

      // ç¿»è½¬å¡ç‰‡
      const updatedCards = cards.map(card =>
        card.id === cardId ? { ...card, isFlipped: true } : card
      );

      const newSelectedCards = [...selectedCards, clickedCard];

      // å¦‚æœé€‰æ‹©äº†ä¸¤å¼ å¡ç‰‡ï¼Œæ£€æŸ¥æ˜¯å¦åŒ¹é…
      if (newSelectedCards.length === 2) {
        const [firstCard, secondCard] = newSelectedCards;
        const isMatch = firstCard.pairId === secondCard.pairId;

        if (isMatch) {
          // åŒ¹é…æˆåŠŸ
          const finalCards = updatedCards.map(card =>
            card.pairId === firstCard.pairId 
              ? { ...card, isMatched: true }
              : card
          );

          const newMatchedPairs = matchedPairs + 1;
          const newSteps = steps + 1;
          const isGameCompleted = newMatchedPairs === currentWords.length;

          return {
            ...prevState,
            cards: finalCards,
            selectedCards: [],
            matchedPairs: newMatchedPairs,
            steps: newSteps,
            isGameCompleted,
            endTime: isGameCompleted ? Date.now() : null
          };
        } else {
          // åŒ¹é…å¤±è´¥ï¼Œå»¶è¿Ÿç¿»å›å¡ç‰‡
          setTimeout(() => {
            setGameState(currentState => ({
              ...currentState,
              cards: currentState.cards.map(card =>
                (card.id === firstCard.id || card.id === secondCard.id)
                  ? { ...card, isFlipped: false }
                  : card
              ),
              selectedCards: []
            }));
          }, 500);

          return {
            ...prevState,
            cards: updatedCards,
            selectedCards: newSelectedCards,
            steps: steps + 1
          };
        }
      }

      return {
        ...prevState,
        cards: updatedCards,
        selectedCards: newSelectedCards
      };
    });
  }, [currentWords.length]);

  // æ¸¸æˆå®Œæˆå¤„ç†
  useEffect(() => {
    if (gameState.isGameCompleted && gameState.startTime && gameState.endTime && selectedLibrary) {
      const timeSeconds = Math.floor((gameState.endTime - gameState.startTime) / 1000);
      
      const saveRecordAndGetRanking = async () => {
        if (playerName.trim()) {
          try {
            // å…ˆè·å–ç”¨æˆ·çš„å†å²æœ€ä½³è®°å½•
            const existingRecords = await gameRecordApi.getLeaderboard(selectedLibrary.id, currentWords.length);
            const userRecords = existingRecords.filter(record => record.player_name === playerName.trim());
            
            let isNewRecord = false;
            if (userRecords.length > 0) {
              // ç”¨æˆ·æœ‰å†å²è®°å½•ï¼Œæ£€æŸ¥æ˜¯å¦åˆ·æ–°äº†è®°å½•
              const bestUserRecord = userRecords[0]; // æ’è¡Œæ¦œå·²æŒ‰æ—¶é—´æ’åºï¼Œç¬¬ä¸€ä¸ªå°±æ˜¯æœ€ä½³è®°å½•
              
              // æ¯”è¾ƒæ–°è®°å½•æ˜¯å¦æ›´å¥½ï¼ˆæ—¶é—´æ›´çŸ­ï¼Œæˆ–æ—¶é—´ç›¸åŒä½†æ­¥æ•°æ›´å°‘ï¼‰
              if (timeSeconds < bestUserRecord.time_seconds || 
                  (timeSeconds === bestUserRecord.time_seconds && gameState.steps < bestUserRecord.steps)) {
                isNewRecord = true;
              }
            } else {
              // ç”¨æˆ·ç¬¬ä¸€æ¬¡æ¸¸æˆï¼Œä¹Ÿç®—æ–°è®°å½•
              isNewRecord = true;
            }
            
            // æ›´æ–°æ¸¸æˆæ¬¡æ•°
            const newGameCount = userRecords.length + 1;
            setGameCount(newGameCount);
            // ä¿å­˜æ–°è®°å½•
            await gameRecordApi.create({
              player_name: playerName.trim(),
              library_id: selectedLibrary.id,
              word_count: currentWords.length,
              steps: gameState.steps,
              time_seconds: timeSeconds
            });
            
            // æ¸¸æˆè®°å½•ä¿å­˜æˆåŠŸåï¼Œè·å–æ’åä¿¡æ¯
            await getRankingInfo();
            
            // è§¦å‘æ’è¡Œæ¦œåˆ·æ–°
            setLeaderboardRefreshKey(Date.now());
            
            // æ ¹æ®æ˜¯å¦åˆ·æ–°è®°å½•æ˜¾ç¤ºä¸åŒçš„æç¤º
            if (isNewRecord && userRecords.length > 0) {
              toast.success(`ğŸ‰ é‡å¤å¸¦æ¥å¤©èµ‹ï¼Œæ‚¨åˆåˆ·æ–°è®°å½•ï¼ç”¨æ—¶ ${timeSeconds} ç§’ï¼Œå…± ${gameState.steps} æ­¥`);
            } else {
              toast.success(`æ­å–œå®Œæˆæ¸¸æˆï¼ç”¨æ—¶ ${timeSeconds} ç§’ï¼Œå…± ${gameState.steps} æ­¥`);
            }
          } catch (error) {
            console.error('ä¿å­˜æ¸¸æˆè®°å½•å¤±è´¥:', error);
            toast.error('ä¿å­˜æ¸¸æˆè®°å½•å¤±è´¥');
          }
        } else {
          // å³ä½¿æ²¡æœ‰ä¿å­˜è®°å½•ï¼Œä¹Ÿè·å–æ’åä¿¡æ¯
          await getRankingInfo();
          toast.success(`æ­å–œå®Œæˆæ¸¸æˆï¼ç”¨æ—¶ ${timeSeconds} ç§’ï¼Œå…± ${gameState.steps} æ­¥`);
        }
      };

      saveRecordAndGetRanking();
    }
  }, [gameState.isGameCompleted, gameState.startTime, gameState.endTime, gameState.steps, selectedLibrary, currentWords.length, playerName]);

  // è·å–æ’åä¿¡æ¯
  const getRankingInfo = async () => {
    if (!selectedLibrary) return;
    
    try {
      const records = await gameRecordApi.getLeaderboard(selectedLibrary.id, currentWords.length);
      
      if (records.length > 0) {
        // è·å–ç¬¬ä¸€åä¿¡æ¯
        const firstPlace = records[0];
        setFirstPlaceRecord({
          playerName: firstPlace.player_name,
          time: firstPlace.time_seconds,
          steps: firstPlace.steps
        });
        
        // å¦‚æœç”¨æˆ·æœ‰åå­—ï¼ŒæŸ¥æ‰¾ç”¨æˆ·çš„æœ€ä½³æ’å
        if (playerName.trim()) {
          // æ‰¾åˆ°ç”¨æˆ·çš„æ‰€æœ‰è®°å½•ä¸­æœ€å¥½çš„ä¸€ä¸ª
          const userRecords = records.filter(record => record.player_name === playerName.trim());
          if (userRecords.length > 0) {
            // ç”¨æˆ·çš„æœ€ä½³è®°å½•å°±æ˜¯æ’è¡Œæ¦œä¸­çš„ç¬¬ä¸€ä¸ªç”¨æˆ·è®°å½•
            const bestUserRecord = userRecords[0];
            const userRankIndex = records.findIndex(record => 
              record.player_name === bestUserRecord.player_name && 
              record.time_seconds === bestUserRecord.time_seconds &&
              record.steps === bestUserRecord.steps
            );
            setUserRank(userRankIndex + 1);
          } else {
            setUserRank(null);
          }
        } else {
          setUserRank(null);
        }
      } else {
        setFirstPlaceRecord(null);
        setUserRank(null);
      }
    } catch (error) {
      console.error("è·å–æ’åä¿¡æ¯å¤±è´¥:", error);
      setFirstPlaceRecord(null);
      setUserRank(null);
    }
  };

  // ç›‘å¬å•è¯æ•°é‡å˜åŒ–ï¼Œè‡ªåŠ¨åˆ·æ–°å•è¯
  useEffect(() => {
    if (wordPairs.length > 0 && !gameState.isGameStarted) {
      refreshWords(wordPairs, wordCount);
    }
  }, [wordCount, wordPairs, gameState.isGameStarted, refreshWords]);

  // è®¡ç®—æ¸¸æˆè¿›åº¦
  const progress = gameState.isGameStarted 
    ? (gameState.matchedPairs / currentWords.length) * 100 
    : 0;

  // è®¡ç®—æ¸¸æˆæ—¶é—´
  const gameTime = gameState.startTime 
    ? Math.floor(((gameState.endTime || Date.now()) - gameState.startTime) / 1000)
    : 0;

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 via-blue-50 to-indigo-100 p-4">
      <div className="max-w-4xl mx-auto space-y-6">
        {/* æ ‡é¢˜ */}
        <div className="text-center">

        </div>

        {/* æ¸¸æˆæœªå¼€å§‹æ—¶æ˜¾ç¤ºå•è¯åˆ—è¡¨ */}
        {!gameState.isGameStarted && (
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center justify-between">
                <span>å½“å‰å•è¯</span>
                <div className="flex items-center gap-2">
                  {!showAddWords ? (
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => setShowAddWords(true)}
                      className="flex items-center gap-1"
                    >
                      <Plus className="w-4 h-4" />
                      åŠ è¯æ¨¡å¼
                    </Button>
                  ) : (
                    <div className="flex items-center gap-2">
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setWordCount(Math.max(10, wordCount - 2))}
                      >
                        <Minus className="w-4 h-4" />
                      </Button>
                      <Badge variant="outline" className="min-w-[3rem] text-center">
                        {wordCount}
                      </Badge>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setWordCount(Math.min(wordPairs.length, wordCount + 2))}
                      >
                        <Plus className="w-4 h-4" />
                      </Button>
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => setShowAddWords(false)}
                      >
                        å®Œæˆ
                      </Button>
                    </div>
                  )}
                </div>
              </CardTitle>
            </CardHeader>
            <CardContent>
              {currentWords.length > 0 ? (
                <div className="grid grid-cols-4 gap-1.5 mb-6">
                  {currentWords.map((pair, index) => [
                    // è‹±æ–‡å¡ç‰Œ
                    <div
                      key={`${pair.id}-en`}
                      className="p-1.5 bg-blue-50 rounded-md border border-blue-200 text-center aspect-square flex items-center justify-center"
                    >
                      <span className="font-medium text-blue-700 text-xs leading-tight">
                        {pair.english_word}
                      </span>
                    </div>,
                    // ä¸­æ–‡å¡ç‰Œ
                    <div
                      key={`${pair.id}-zh`}
                      className="p-1.5 bg-slate-50 rounded-md border border-slate-200 text-center aspect-square flex items-center justify-center"
                    >
                      <span className="text-slate-700 text-xs leading-tight">
                        {pair.chinese_translation}
                      </span>
                    </div>
                  ]).flat()}
                </div>
              ) : (
                <div className="text-center py-8 text-slate-500">
                  æš‚æ— å•è¯ï¼Œè¯·åˆ·æ–°æˆ–æ£€æŸ¥è¯åº“
                </div>
              )}

              <Separator className="my-4" />

              {/* æ“ä½œæŒ‰é’® */}
              <div className="flex flex-wrap gap-3 justify-center">
                <Button
                  onClick={() => refreshWords()}
                  variant="outline"
                  className="flex items-center gap-2"
                  disabled={wordPairs.length === 0}
                >
                  <RefreshCw className="w-4 h-4" />
                  åˆ·æ–°å•è¯
                </Button>
                
                <Button
                  onClick={startGame}
                  className="flex items-center gap-2"
                  disabled={currentWords.length === 0}
                >
                  <Play className="w-4 h-4" />
                  å¼€å§‹æ¸¸æˆ
                </Button>

                <Link to="/settings">
                  <Button
                    variant="outline"
                    className="flex items-center gap-2"
                  >
                    <Settings2 className="w-4 h-4" />
                    æ›´å¤šè®¾ç½®
                  </Button>
                </Link>

                <Link to="/test-settings">

                </Link>
              </div>
            </CardContent>
          </Card>
        )}

        {/* æ¸¸æˆè¿›è¡Œä¸­çš„ç»Ÿè®¡é¢æ¿ */}
        {gameState.isGameStarted && (
          <Card className="mt-1">
            <CardContent className="py-2 px-4">
              <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-2">
                {/* æ¸¸æˆç»Ÿè®¡ä¿¡æ¯ */}
                <div className="flex flex-wrap items-center gap-3 sm:gap-4">
                  <div className="flex items-center gap-1.5">
                    <Target className="w-3.5 h-3.5 text-blue-600" />
                    <span className="text-sm font-medium">{Math.round(progress)}%</span>
                  </div>
                  <div className="flex items-center gap-1.5">
                    <Trophy className="w-3.5 h-3.5 text-amber-600" />
                    <span className="text-sm font-medium">{gameState.steps}æ­¥</span>
                  </div>
                  {gameState.startTime && (
                    <div className="flex items-center gap-1.5">
                      <Clock className="w-3.5 h-3.5 text-green-600" />
                      <span className="text-sm font-medium">{gameTime}ç§’</span>
                    </div>
                  )}
                </div>

                {/* æ¸¸æˆæ§åˆ¶æŒ‰é’® */}
                <div className="flex items-center gap-1.5">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={restartGame}
                    className="flex items-center gap-1 h-7 px-2 text-xs"
                  >
                    <RotateCcw className="w-3.5 h-3.5" />
                    é‡æ–°å¼€å§‹
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={resetGame}
                    className="flex items-center gap-1 h-7 px-2 text-xs"
                  >
                    <ArrowLeft className="w-3.5 h-3.5" />
                    è¿”å›
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        )}

        {/* æ¸¸æˆåŒºåŸŸ */}
        {gameState.isGameStarted && (
          <GameBoard
            cards={gameState.cards}
            onCardClick={handleCardClick}
            isCompleted={gameState.isGameCompleted}
          />
        )}

        {/* æ¸¸æˆå®Œæˆæç¤º */}
        {gameState.isGameCompleted && (
          <Card className="border-green-200 bg-green-50">
            <CardContent className="pt-6">
              <div className="text-center space-y-4">

                <div className="text-green-600">
                  ç”¨æ—¶ {gameTime} ç§’ï¼Œå…± {gameState.steps} æ­¥
                </div>
                {/* æ’åä¿¡æ¯ */}
                {(userRank || firstPlaceRecord) && (
                  <div className="bg-white rounded-lg p-4 space-y-3 border border-green-100">
                    <div className="text-sm font-medium text-gray-700 mb-2">æ’åä¿¡æ¯</div>
                    
                    {/* ç¬¬ä¸€åä¿¡æ¯ */}
                    {firstPlaceRecord && (
                      <div className="flex items-center justify-between p-2 bg-yellow-50 rounded-md border border-yellow-200">
                        <div className="flex items-center gap-2">
                          <Crown className="w-4 h-4 text-yellow-600" />
                          <span className="text-sm font-medium text-yellow-800">ç¬¬ä¸€å</span>
                        </div>
                        <div className="text-sm text-yellow-700">
                          {firstPlaceRecord.playerName} - {firstPlaceRecord.time}ç§’ {firstPlaceRecord.steps}æ­¥
                        </div>
                      </div>
                    )}

                    {/* ç”¨æˆ·æ’å */}
                    {userRank && playerName.trim() && (
                      <div className="flex items-center justify-between p-2 bg-blue-50 rounded-md border border-blue-200">
                        <div className="flex items-center gap-2">
                          <Medal className="w-4 h-4 text-blue-600" />
                          <span className="text-sm font-medium text-blue-800">æ‚¨çš„æ’å</span>
                        </div>
                        <div className="text-sm text-blue-700">
                          ç¬¬ {userRank} å
                        </div>
                      </div>
                    )}

                    {/* æœªç™»å½•æç¤º */}
                    {!playerName.trim() && (
                      <div className="text-xs text-gray-500 text-center">
                        è®¾ç½®ç©å®¶åç§°åå¯æŸ¥çœ‹ä¸ªäººæ’å
                      </div>
                    )}
                  </div>
                )}
                <div className="flex gap-2 justify-center">
                  <Button onClick={resetGame} className="flex items-center gap-2">
                    <Play className="w-4 h-4" />
                    å†ç©ä¸€å±€
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        )}
      </div>
      
      {/* æ’è¡Œæ¦œå¯¹è¯æ¡† */}
      <Leaderboard
        open={showLeaderboard}
        onOpenChange={setShowLeaderboard}
        selectedLibrary={selectedLibrary}
        wordCount={currentWords.length}
        refreshKey={leaderboardRefreshKey}
      />
    </div>
  );
};

export default WordMatchGame;